\include{settings}

\begin{document}	% начало документа

\include{titlepage}


% Содержание
\hypertarget{toc}
\tableofcontents
\newpage

%TODO

\section*{Игра Го}
\addcontentsline{toc}{section}{Глава 1. Игра Го}

%Глава -- Описание предметной области (должно называться типа "Японская игра Сеги", "Эмулятор звездной системы", "Модель хищник-жертва" и %т. п.). Там размещаем то, что есть в ваших репозиториях в README.md, кроме диаграммы компонентов.\\

\subsection*{Задание}
  Разработать приложение для игры Го.\\

\subsection*{Правила игры}

\subsubsection*{Основная часть}
\begin{itemize}

\item Го представляет собой доску размера $19 \times 19$ пунктов (пересечений прямых линий) и камни двух цветов: чёрные и белые. В Го задействованы 2 игрока, один из которых играет чёрными камнями, а другой - белыми. Распределение игровых цветов между соперниками происходит в соответствии с процедурой нигири. Изначально доска пуста. Правом первого хода обладает игрок, которому достались чёрные камни. Далее игроки до завершения игры поочерёдно делают ходы. Засчёт того, что чёрные обладают правом первого хода, белым дается компенсация ввиде коми - определённого нецелого числа очков.\\

\item Процедура нигири подразумевает следующее: один игрок берет в руку горсть белых камней так, чтобы соперник не видел их количество. Другой берет один или два чёрных камня, тем самым пытаясь угадать соответственно чётность или нечётность количества белых камней. Затем игроки выкладывают камни на доску. Если второй игрок угадал чётность, то он играет чёрными, а в противном случае - белыми.\\

\item Ход заключается в том, что игрок пассует (пропускает ход) или устанавливает камень своего цвета в любой свободный пункт на доске, если это не противоречит двум правилам:
  \begin{enumerate}
  
  \item Устанавливаемый камень должен иметь хотя бы одно дыхание. Дыханием называется свободный соседний пункт, соединенный с данным камнем по прямой линии. Тем не менее, ход может быть осуществлен так, что устанавливаемый камень лишает свою группу дыхания, но при этом лишает дыхания еще и группу соперника, тем самым съедая её.\\
 
  \item  Данный ход игрока не повторяет его предыдущий ход.\\
  
  \end{enumerate}

\item Съедение группы камней (или одного камня) соперника считается осуществлённым, если эта группа камней не имеет
    ни одного дыхания, то есть ни один камень группы не имеет дыханий. Съеденные камни снимаются с доски и остаются до
    конца игры у "съевшего" их игрока.\\
    
\item Цель игроков - к концу игры набрать больше очков, чем соперник. Очко даётся за каждый пункт захваченной территории и, в зависимости от правил, за съеденный или захваченный камень соперника или свой живой камень. Территория считается захваченной игроком, если при максимально эффективной игре обоих игроков он сможет съесть или захватить все камни соперника на данной территории. Захваченный камень - это камень соперника, который имеет дыхания, но при желании игрока может быть съеден.\\

\item Игра завершается в трёх случаях:


\begin{enumerate}

	\item Один из игроков сдается.\\
	\item В ответ на пропуск хода одним игроком следует пропуск хода другим.\\
	\item  Не осталось ходов, способных повлиять на ситуацию на доске.\\

\end{enumerate}

\item Все разыгрываемые в партии очки - целые. Поэтому, с учётом того, что коми - нецелое число, победитель определяется всегда.\\

\end{itemize}

\subsubsection*{Особенности японских правил}

\begin{enumerate}

\item Коми составляет 6,5 очков.\\
\item Способ подсчета очков: размер территории + количество захваченных камней противника, включая съеденные камни + коми (для белых).

\end{enumerate}

\subsubsection*{Особенности китайских правил}

\begin{enumerate}

\item Коми составляет 7,5 очков.\\
\item Способ подсчета очков: размер территории + количество своих живых камней (то есть камней, выставленных на доску и не взятых противником) + коми (для белых).\\

\end{enumerate}
 
\subsection*{Концепция}

  Готовый продукт является кроссплатформенным и содержит приложение как консольное, так и с графическим интерфесом. Есть искусственный интеллект (ИИ), который обладает простой логикой, а не случайно ходит в свободный пункт. Имеется возможность выбрать правила игры: японские или китайские. Определенный правилами размер игровой доски $19 \times 19$ пунктов можно изменить на $13 \times 13$ и $7 \times 7$. Наличие ИИ позволяет не только играть двоим пользователям друг против друга, но и играть одному пользователю против ИИ. Выбор цвета камней происходит либо по договоренности (в случае игры против ИИ цвет выбирает пользователь), либо в соответствии с реализованной традиционной процедурой нигири. Ход событий текущей партии можно сохранить и в дальнейшем - загрузить и продолжить. Пользовательский интерфейс включает справочную систему как по самому интерфейсу, так и по игровому процессу.
  
  Разработка сопровождается модульным и функциональным тестированием на всех этапах.

\subsection*{Минимально работоспособный продукт}

 Кроссплатформеное консольное приложение, позволяющее совершать ходы двоим пользователям.
  
\subsection*{Диаграммы вариантов использования}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.65]{../UMLdiagrams/UseCase/GameOrganisation.png}
		%\caption{название картинки} 
		\label{pic:GameOrganisation}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.545]{../UMLdiagrams/UseCase/GameProcess.png}
		%\caption{название картинки} 
		\label{pic:GameProcess}
	\end{center}
\end{figure}

\section*{Проектирование приложения, реализующего игру Го}
\addcontentsline{toc}{section}{Глава 2. Проектирование приложения, реализующего эмулятор игры Го}

%Глава -- Проектирование ("Проектирование приложения, реализующего эмулятор звездной системы/японскую игру сеги/модель хищник-жертва". %Здесь описываете архитектуру приложения -- сколько каких подпроектов (какие библиотеки, приложения, тесты), диаграмма компонентов, %описание выделенных интерфейсов (API) человеческим языком, дополнительных библиотек (если использовали), версии языка, кьюти, %компилятора. Описать структуру файлов, если какие-то создаются в процессе работы приложения.\\

В ходе проектирования было принято решение выделить 6 подпроектов: движок - \textbf{GoEngine}, тесты - \textbf{GoTests}, база данных - \textbf{GoDatabase}, 
искусственный интеллект - \textbf{XiGo}, консольное приложение - \textbf{GoCUI} и приложение с графическим интерфейсом - \textbf{GoGUI}. 

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.49]{../UMLdiagrams/Component/Component.png}
		%\caption{название картинки} 
		\label{pic:Component}
	\end{center}
\end{figure}

\subsection*{GoEngine}

Подпроект \textbf{GoEngine} - это библиотека, реализующая бизнес-логику игры Го.

\subsubsection*{GoEngine API}

Интерфейс программирования приложения.\\

\begin{itemize}

\item\textbf{void startGame(const int diagonal, const int rules, const int colorDistribution) noexcept override}\\
	
	Создает все объекты, необходимые для игрового процесса. Длина диагонали, правила подсчета очков и способ распределения цветов задаются
	соответственно из параметров diagonal, rules, colorDistribution.\\

\item\textbf{void putStone(const int first, const int second) override}\\
	
	Устанавливает камень игрока, чей ход, в пункт с парой координат (first, second).\\


\item\textbf{void pass() noexcept override}\\

	Устанавливает пропуск хода игроком.\\

\item\textbf{void surrender() noexcept override}\\

	Повзоляет сдаться игроку, чей ход.\\

\item\textbf{Status whoseMove() const noexcept override}\\

	Определяет, чей ход.\\

\item\textbf{bool isGameOver() const noexcept override}\\

	Определяет, окончена ли игра.\\

\item\textbf{Status whoSurrendered() const noexcept override}\\

	Определяет цвет сдавшегося игрока.\\

\item\textbf{Status whoWon() const noexcept override}\\

	Определяет цвет победившего игрока.\\

\item\textbf{int getDiagonal() const noexcept override}\\

	Возвращает значение диагонали доски.\\

\item\textbf{Status getPointsStatus(const int first, const int second) const noexcept override}\\
	
	Определяет статус пункта доски с парой координат (first, second).\\

\item\textbf{int getStonesEatenByBlack() const noexcept override}\\

	Возвращает число съеденных чёрными камней.\\

\item\textbf{int getStonesEatenByWhite() const noexcept override}\\

	Возвращает число съеденных белыми камней.\\

\item\textbf{int getMoveIndex() const noexcept override}\\

	Определяет индекс текущего хода.\\

\item\textbf{std::vector<Move> \&getMoves() const noexcept override}\\

	Возвращает вектор, содержащий ходы.\\

\item\textbf{Move \&getLastMove() const noexcept override}\\

	Возвращает последний совершённый ход.\\

\item\textbf{Move \&getPenultMove() const noexcept override}\\

	Возвращает предпоследний совершённый ход.\\

\item\textbf{int getBlackScore() const noexcept override}\\

	Определяет число очков чёрного игрока.\\

\item\textbf{int getWhiteScore() const noexcept override}\\	

	Определяет число очков белого игрока.\\

\end{itemize}

\subsection*{GoTests}

Подпроект GoTests включает два подпроекта: модульные тесты - \textbf{UnitTests} и функциональные - \textbf{FunctionalTest}.\\

\subsubsection*{UnitTests}
Данный подпроект содержит 5 классов - модульные тесты для 5 классов соответственно из движка GoEngine, которые несут основную функциональную нагрузку:

\begin{itemize}
	\item StoneTest\\
	\item PointTest\\
	\item BoardTest\\
	\item MoveTest\\
	\item GameProcessTest\\
\end{itemize}

\subsubsection*{FunctionalTest}
Данный подпроект содержит 1 класс - \textbf{functionalTest}, задача которого - функциональное тестирование движка \textbf{GoEngine}. В данном классе происходила проверка функиональностей, которые в дальнейшем включались в приложение.

\subsection*{GoDatabase}

База данных, необходимая для загрузки и сохранения процесса игры приложения.\\

\section*{Реализация игры Го}
\addcontentsline{toc}{section}{Глава 3. Реализация игры Го}

%Глава -- Реализация ("Реализация японской игры сеги/модели хищник-жертва"). Здесь описываете среду разработки (версии всех использованых %ос, компиляторов, сред, утилит (qt creator, doxygen, прочее)), очень поверхностно описываете, какие основные классы выделили в каждом из %проектов, если какие-то интересные паттерны или алгоритмы -- тоже. Можно тут рассказать, сколько строк кода. Приводите скрины основных %%экранов пользовательского интерфейса, но чтоб не только картинки, но еще и слова, описывающие то, что видно на картинке. К картинкам не %забывайте делать подписи.

\subsection*{Среда разработки}
\textbf{
Операционная система:} Windows 10.0.10586\\
\textbf{Интегрированная среда разработки:} CLion 2016.1.2\\
\textbf{Стандарт с++:} c++11\\
\textbf{Компилятор:} MinGW 3.21\\
\textbf{Система автоматизации сборки:} CMake 3.5.1\\
\textbf{Система документирования:} Doxygen 1.8.11\\
\textbf{Утилита для подсчёта строк:} cloc 1.66\\

\subsection*{GoEngine}

Было выделено 13 классов. Из них 2 относятся к интерфейсу движка, 2 - к правилам игры, 3 - к игровой модели и 6 - к исключениям. Утилитой cloc было посчитано, что в GoEngine 568 строк кода на c++.

\subsection*{GoDatabase}

Не реализовано на данный момент.\\

\subsection*{GoCUI}

Было выделено 2 класса. Один из них, Help, реализует систему помощи. Другой - GoGame - реализует игровой процесс. Утилитой cloc было посчитано, что в GoCUI 792 строк c++-го кода. Данное приложение находится в состоянии mvp.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Menu.png}
	    \caption{Главное меню} 
		\label{pic:CUI_Menu}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Help.png}
	    \caption{Помощь} 
		\label{pic:CUI_Help}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Process.png}
	    \caption{Игровой процесс} 
		\label{pic:CUI_Process}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Out.png}
	    \caption{Предупреждение о выходе за границы доски} 
		\label{pic:CUI_Out}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/NotEmpty.png}
	    \caption{Предупреждение о ходе в несвободный пункт} 
		\label{pic:CUI_NotEmpty}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Pass.png}
	    \caption{Предупреждение о пропуске соперником хода и завершение игры после двух попусков подряд} 
		\label{pic:CUI_Pass}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoCUI/Surrender.png}
	    \caption{Чёрный игрок сдался} 
		\label{pic:CUI_Surrender}
	\end{center}
\end{figure}

\subsection*{GoGUI}

В приложении реализовано на данный момент: окно меню, окно настроек и окно игрового процесса без доски, но с работающими кнопками,
влиющими на игровой процесс.

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.5]{pics/GoGUI/Menu.png}
	    \caption{Главное меню} 
		\label{pic:CUI_Menu}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.6]{pics/GoGUI/Settings.png}
	    \caption{Предыгровые настройки} 
		\label{pic:CUI_Settings}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.5]{pics/GoGUI/Game.png}
	    \caption{Окно игрового процесса} 
		\label{pic:CUI_Game}
	\end{center}
\end{figure}

\section*{Процесс обеспечения качества и тестирование}
\addcontentsline{toc}{section}{Глава 4. Процесс обеспечения качества и тестирование}

%Глава -- "Процесс обеспечения качества и тестирование". Здесь описываете процесс разработки -- количество ревью (и примерное количество %замечаний), количество демонстраций (с указанием конкретных замечаний и комментариями по ним), список использованных утилит (cppcheck, %valgrind, gcov и т.д, кто пользовался jenkins -- про него тоже) с комментариями как и когда они помогали. Рассказать про автоматические %тесты (модульные, функциональные), про тестовые сценарии, которые они покрывают, процент покрытия. Рассказать про тестовые сценарии для %ручных тестов.

empty

\section*{Выводы}
\addcontentsline{toc}{section}{Глава 5. Выводы}

своими словами, с душой, от чистого сердца рассказать, чему удалось научиться за семестр, что извлечь.


\section*{Приложения}
\addcontentsline{toc}{section}{Приложения}

\subsection*{Приложение 1. Листинги кода}
\addcontentsline{toc}{subsection}{Приложение 1. Листинги кода}


\subsection*{Приложение 2. Doxygen документация}
\addcontentsline{toc}{subsection}{Приложение 2. Doxygen документация}

\subsection*{Список}

\begin{itemize}
\item первый элемент списка
\item второй элемент списка
\end{itemize}


\subsection*{Картинка}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/sample}
		\caption{название картинки} 
		\label{pic:pic_name} % название для ссылок внутри кода
	\end{center}
\end{figure}


\subsection*{Листинг}

\captionof{lstlisting}{hell\_o.c} % для печати символ '_' требует выходной символ '\'
\lstinputlisting[label=code:hello]{listings/hell_o.c}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа
Текст без отступа (следует за вставкой)

Новый параграф

\noindent Новый параграф с принудительно выключенным отступом


\subsection*{Частичный листинг}
% настрока частичного ввода (требуется один раз)
\makeatletter
\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\the\lst@lineno}\kern\lst@numbersep}}
\makeatother

\captionof{lstlisting}{фрагмент hell\_o.c}
\lstinputlisting[label=code:hello_mod, linerange={4-5}]{listings/hell_o.c}
\parindent=1cm

\subsection*{Таблица}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|l|l|}
			\hline
			top left & top right\\ \hline
			bot left & bot right\\ \hline
		\end{tabular}
		\caption{ Название таблицы}
		\label{tabular:tab_examp}
	\end{center}
\end{table}

\section*{Выводы}
\LaTeX\ удобен для создания отчётов, так как сам следит за нумерацией таблиц, рисунков, листингов и отсылок к ним (так, например, здесь всегда будет указан номер рисунка "sample" не зависимо от того, какой он (1,2 или другой) - это рисунок \ref{pic:pic_name}). Не менее важно что весь документ оформлен в едином стиле, а исходные материалы подключаются к отчёту, а не хранятся в нём. Всё это позволяет легко получить качественный отчёт без дополнительных трат на его офрмление.

Исключения, пожалуй, составляют таблицы, так как их значительно сложнее создавать кодом, нежели в графическом редакторе. Но здесь никто не запрещает использовать визуальные средства создания таблиц для \LaTeX\ .
\end{document}
