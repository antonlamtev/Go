\include{settings}

\begin{document}	% начало документа

\include{titlepage}


% Содержание
\hypertarget{toc}
\tableofcontents
\newpage

%TODO

\section*{Игра Го}
\addcontentsline{toc}{section}{Глава 1. Игра Го}

Глава -- Описание предметной области (должно называться типа "Японская игра Сеги", "Эмулятор звездной системы", "Модель хищник-жертва" и т. п.). Там размещаем то, что есть в ваших репозиториях в README.md, кроме диаграммы компонентов.\\

\subsection*{Задание}
  Разработать приложение для игры Го.\\

\subsection*{Правила игры}

\subsubsection*{Основная часть}
\begin{itemize}

\item Го представляет собой доску размера $19 \times 19$ пунктов (пересечений прямых линий) и камни двух цветов: чёрные и белые. В Го задействованы 2 игрока, один из которых играет чёрными камнями, а другой - белыми. Распределение игровых цветов между соперниками происходит в соответствии с процедурой нигири. Изначально доска пуста. Правом первого хода обладает игрок, которому достались чёрные камни. Далее игроки до завершения игры поочерёдно делают ходы. Засчёт того, что чёрные обладают правом первого хода, белым дается компенсация ввиде коми - определённого нецелого числа очков.\\

\item Процедура нигири подразумевает следующее: один игрок берет в руку горсть белых камней так, чтобы соперник не видел их количество. Другой берет один или два чёрных камня, тем самым пытаясь угадать соответственно чётность или нечётность количества белых камней. Затем игроки выкладывают камни на доску. Если второй игрок угадал чётность, то он играет чёрными, а в противном случае - белыми.\\

\item Ход заключается в том, что игрок пассует (пропускает ход) или устанавливает камень своего цвета в любой свободный пункт на доске, если это не противоречит двум правилам:
  \begin{enumerate}
  
  \item Устанавливаемый камень должен иметь хотя бы одно дыхание. Дыханием называется свободный соседний пункт, соединенный с данным камнем по прямой линии. Тем не менее, ход может быть осуществлен так, что устанавливаемый камень лишает свою группу дыхания, но при этом лишает дыхания еще и группу соперника, тем самым съедая её.\\
 
  \item  Данный ход игрока не повторяет его предыдущий ход.\\
  
  \end{enumerate}

\item Съедение группы камней (или одного камня) соперника считается осуществлённым, если эта группа камней не имеет
    ни одного дыхания, то есть ни один камень группы не имеет дыханий. Съеденные камни снимаются с доски и остаются до
    конца игры у "съевшего" их игрока.\\
    
\item Цель игроков - к концу игры набрать больше очков, чем соперник. Очко даётся за каждый пункт захваченной территории и, в зависимости от правил, за съеденный или захваченный камень соперника или свой живой камень. Территория считается захваченной игроком, если при максимально эффективной игре обоих игроков он сможет съесть или захватить все камни соперника на данной территории. Захваченный камень - это камень соперника, который имеет дыхания, но при желании игрока может быть съеден.\\

\item Игра завершается в трёх случаях:


\begin{enumerate}

	\item Один из игроков сдается.\\
	\item В ответ на пропуск хода одним игроком следует пропуск хода другим.\\
	\item  Не осталось ходов, способных повлиять на ситуацию на доске.\\

\end{enumerate}

\item Все разыгрываемые в партии очки - целые. Поэтому, с учётом того, что коми - нецелое число, победитель определяется всегда.\\

\end{itemize}

\subsubsection*{Особенности японских правил}

\begin{enumerate}

\item Коми составляет 6,5 очков.\\
\item Способ подсчета очков: размер территории + количество захваченных камней противника, включая съеденные камни + коми (для белых).

\end{enumerate}

\subsubsection*{Особенности китайских правил}

\begin{enumerate}

\item Коми составляет 7,5 очков.\\
\item Способ подсчета очков: размер территории + количество своих живых камней (то есть камней, выставленных на доску и не взятых противником) + коми (для белых).\\

\end{enumerate}
 
\subsection*{Концепция}

  Готовый продукт является кроссплатформенным и содержит приложение как консольное, так и с графическим интерфесом. Есть искусственный интеллект (ИИ), который обладает простой логикой, а не случайно ходит в свободный пункт. Имеется возможность выбрать правила игры: японские или китайские. Определенный правилами размер игровой доски $19 \times 19$ пунктов можно изменить на $13 \times 13$ и $7 \times 7$. Наличие ИИ позволяет не только играть двоим пользователям друг против друга, но и играть одному пользователю против ИИ. Выбор цвета камней происходит либо по договоренности (в случае игры против ИИ цвет выбирает пользователь), либо в соответствии с реализованной традиционной процедурой нигири. Ход событий текущей партии можно сохранить и в дальнейшем - загрузить и продолжить. Пользовательский интерфейс включает справочную систему как по самому интерфейсу, так и по игровому процессу.
  
  Разработка сопровождается модульным и функциональным тестированием на всех этапах.

\subsection*{Минимально работоспособный продукт}

 Кроссплатформеное консольное приложение, позволяющее совершать ходы двоим пользователям.
  
\subsection*{Диаграммы вариантов использования}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.65]{../UMLdiagrams/UseCase/GameOrganisation.png}
		%\caption{название картинки} 
		\label{pic:GameOrganisation}
	\end{center}
\end{figure}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.545]{../UMLdiagrams/UseCase/GameProcess.png}
		%\caption{название картинки} 
		\label{pic:GameProcess}
	\end{center}
\end{figure}

\section*{Проектирование приложения, реализующего игру Го}
\addcontentsline{toc}{section}{Глава 2. Проектирование приложения, реализующего эмулятор игры Го}

Глава -- Проектирование ("Проектирование приложения, реализующего эмулятор звездной системы/японскую игру сеги/модель хищник-жертва". Здесь описываете архитектуру приложения -- сколько каких подпроектов (какие библиотеки, приложения, тесты), диаграмма компонентов, описание выделенных интерфейсов (API) человеческим языком, дополнительных библиотек (если использовали), версии языка, кьюти, компилятора. Описать структуру файлов, если какие-то создаются в процессе работы приложения.\\

В ходе проектирования было принято решение выделить 6 подпроектов: движок - \textbf{GoEngine}, тесты - \textbf{GoTests}, база данных - \textbf{GoDatabase}, 
искусственный интеллект - \textbf{XiGo}, консольное приложение - \textbf{GoCUI} и приложение с графическим интерфейсом - \textbf{GoGUI}. 

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.49]{../UMLdiagrams/Component/Component.png}
		%\caption{название картинки} 
		\label{pic:Component}
	\end{center}
\end{figure}

\subsection*{GoEngine}

Подпроект \textbf{GoEngine} - это библиотека, реализующая бизнес-логику игры Го.

\subsubsection*{GoEngine API}

Интерфейс программирования приложения.\\

\begin{itemize}

\item\textbf{void startGame(const int diagonal, const int rules, const int colorDistribution) noexcept override}\\
	
	Создает все объекты, необходимые для игрового процесса. Длина диагонали, правила подсчета очков и способ распределения цветов задаются
	соответственно из параметров diagonal, rules, colorDistribution.\\


  /**
   * Положить камень в выбранный пункт.
   * @param first первая координата выбранного пункта доски (A - S)
   * @param second вторая координата выбранного пункта доски (1 - 19)
   */
\item\textbf{void putStone(const int first, const int second) override}\\

  /**
   * Пропустить ход.
   */
\item\textbf{void pass() noexcept override}\\

  /**
   * Сдаться.
   */
\item\textbf{void surrender() noexcept override}\\

  /**
   * Чей ход?
   * @return цвет игрока, чей сейчас ход
   */
\item\textbf{Status whoseMove() const noexcept override}\\

  /**
   * Игра закончена?
   * @return true, если игра закончена, и false, если игра не закончена
   */
\item\textbf{bool isGameOver() const noexcept override}\\

  /**
   * Кто сдался?
   * @return цвет игрока, который сдался
   */
\item\textbf{Status whoSurrendered() const noexcept override}\\

  /**
   * Кто победил?
   * @return цвет победителя
   */
\item\textbf{Status whoWon() const noexcept override}\\

  /**
   * Получить диагональ.
   * @return диагональ
   */
\item\textbf{int getDiagonal() const noexcept override}\\

  /**
   * Получить статус first, second - го пункта доски.
   */
\item\textbf{Status getPointsStatus(const int first, const int second) const noexcept override}\\

  /**
   * Получить число камней, съеденных чёрным.
   * @return число камней, съеденных чёрным
   */
\item\textbf{int getStonesEatenByBlack() const noexcept override}\\

  /**
   * Получить число камней, съеденных белым.
   * @return число камней, съеденных белым
   */
\item\textbf{int getStonesEatenByWhite() const noexcept override}\\

  /**
   * Получить индекс хода.
   * @return индекс хода
   */
\item\textbf{int getMoveIndex() const noexcept override}\\

  /**
   * Получить вектор ходов.
   * @return ссылку на вектор ходов.
   */
\item\textbf{std::vector<Move> \&getMoves() const noexcept override}\\

  /**
   * Получить последний совершённый ход.
   * @return ссылку на последний совершённый ход.
   */
\item\textbf{Move \&getLastMove() const noexcept override}\\

  /**
   * Получить предпоследний совершённый ход.
   * @return ссылку на предпоследний совершённый ход
   */
\item\textbf{Move \&getPenultMove() const noexcept override}\\

  /**
   * Получить очки чёрного.
   * @return очки чёрного
   */
\item\textbf{int getBlackScore() const noexcept override}\\

  /**
   * Получить очки белого.
   * @return очки белого
   */
\item\textbf{int getWhiteScore() const noexcept override}\\	

\end{itemize}

\subsection*{GoTests}

Подпроект GoTests включает два подпроекта: модульные тесты - \textbf{UnitTests} и функциональные - \textbf{FunctionalTest}.\\

\subsubsection*{UnitTests}
Данный подпроект содержит 5 классов - модульные тесты для 5 классов соответственно из движка GoEngine, которые несут основную функциональную нагрузку:

\begin{itemize}
	\item StoneTest\\
	\item PointTest\\
	\item BoardTest\\
	\item MoveTest\\
	\item GameProcessTest\\
\end{itemize}

\subsubsection*{FunctionalTest}
Данный подпроект содержит 1 класс - \textbf{functionalTest}, задача которого - функциональное тестирование движка \textbf{GoEngine}. В данном классе происходила проверка функиональностей, которые в дальнейшем включались в приложение.

\section*{Реализация игры Го}
\addcontentsline{toc}{section}{Глава 3. Реализация игры Го}

Глава -- Реализация ("Реализация японской игры сеги/модели хищник-жертва"). Здесь описываете среду разработки (версии всех использованых ос, компиляторов, сред, утилит (qt creator, doxygen, прочее)), очень поверхностно описываете, какие основные классы выделили в каждом из проектов, если какие-то интересные паттерны или алгоритмы -- тоже. Можно тут рассказать, сколько строк кода. Приводите скрины основных экранов пользовательского интерфейса, но чтоб не только картинки, но еще и слова, описывающие то, что видно на картинке. К картинкам не забывайте делать подписи.


\section*{Процесс обеспечения качества и тестирование}
\addcontentsline{toc}{section}{Глава 4. Процесс обеспечения качества и тестирование}

Глава -- "Процесс обеспечения качества и тестирование". Здесь описываете процесс разработки -- количество ревью (и примерное количество замечаний), количество демонстраций (с указанием конкретных замечаний и комментариями по ним), список использованных утилит (cppcheck, valgrind, gcov и т.д, кто пользовался jenkins -- про него тоже) с комментариями как и когда они помогали. Рассказать про автоматические тесты (модульные, функциональные), про тестовые сценарии, которые они покрывают, процент покрытия. Рассказать про тестовые сценарии для ручных тестов.


\section*{Выводы}
\addcontentsline{toc}{section}{Глава 5. Выводы}

своими словами, с душой, от чистого сердца рассказать, чему удалось научиться за семестр, что извлечь.


\section*{Приложения}
\addcontentsline{toc}{section}{Приложения}

\subsection*{Приложение 1. Листинги кода}
\addcontentsline{toc}{subsection}{Приложение 1. Листинги кода}


\subsection*{Приложение 2. Doxygen документация}
\addcontentsline{toc}{subsection}{Приложение 2. Doxygen документация}

\subsection*{Список}

\begin{itemize}
\item первый элемент списка
\item второй элемент списка
\end{itemize}


\subsection*{Картинка}

\begin{figure}[H]
	\begin{center}
		\includegraphics[scale=0.7]{pics/sample}
		\caption{название картинки} 
		\label{pic:pic_name} % название для ссылок внутри кода
	\end{center}
\end{figure}


\subsection*{Листинг}

\captionof{lstlisting}{hell\_o.c} % для печати символ '_' требует выходной символ '\'
\lstinputlisting[label=code:hello]{listings/hell_o.c}
\parindent=1cm % командна \lstinputlisting сбивает параментры отступа
Текст без отступа (следует за вставкой)

Новый параграф

\noindent Новый параграф с принудительно выключенным отступом


\subsection*{Частичный листинг}
% настрока частичного ввода (требуется один раз)
\makeatletter
\def\lst@PlaceNumber{\llap{\normalfont
                \lst@numberstyle{\the\lst@lineno}\kern\lst@numbersep}}
\makeatother

\captionof{lstlisting}{фрагмент hell\_o.c}
\lstinputlisting[label=code:hello_mod, linerange={4-5}]{listings/hell_o.c}
\parindent=1cm

\subsection*{Таблица}

\begin{table}[H]
	\begin{center}
		\begin{tabular}{|l|l|}
			\hline
			top left & top right\\ \hline
			bot left & bot right\\ \hline
		\end{tabular}
		\caption{ Название таблицы}
		\label{tabular:tab_examp}
	\end{center}
\end{table}

\section*{Выводы}
\LaTeX\ удобен для создания отчётов, так как сам следит за нумерацией таблиц, рисунков, листингов и отсылок к ним (так, например, здесь всегда будет указан номер рисунка "sample" не зависимо от того, какой он (1,2 или другой) - это рисунок \ref{pic:pic_name}). Не менее важно что весь документ оформлен в едином стиле, а исходные материалы подключаются к отчёту, а не хранятся в нём. Всё это позволяет легко получить качественный отчёт без дополнительных трат на его офрмление.

Исключения, пожалуй, составляют таблицы, так как их значительно сложнее создавать кодом, нежели в графическом редакторе. Но здесь никто не запрещает использовать визуальные средства создания таблиц для \LaTeX\ .
\end{document}
